<!-- build time:Fri Feb 15 2019 15:55:29 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="s7SsnD6XoVEjf4lGw6yIe12eRfFcaVgdbKYMDPHk0zU"><meta name="yandex-verification" content="4671e153e7289572"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="自由度,原假设,对立假设,"><link rel="alternate" href="/atom.xml" title="值得荐" type="application/atom+xml"><meta name="description" content="Programming is a crucial prerequisite for anyone wanting to learn machine learning. Sure quite a few autoML tools are out there, but most are still at a very nascent stage and well beyond an individua"><meta name="keywords" content="自由度,原假设,对立假设"><meta property="og:type" content="article"><meta property="og:title" content="An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1)"><meta property="og:url" content="http://www.wortyby.com/2018/12/14/An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1)/index.html"><meta property="og:site_name" content="值得荐"><meta property="og:description" content="Programming is a crucial prerequisite for anyone wanting to learn machine learning. Sure quite a few autoML tools are out there, but most are still at a very nascent stage and well beyond an individua"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-12-14T05:10:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1)"><meta name="twitter:description" content="Programming is a crucial prerequisite for anyone wanting to learn machine learning. Sure quite a few autoML tools are out there, but most are still at a very nascent stage and well beyond an individua"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.wortyby.com/2018/12/14/An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1)/"><title>An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1) | 值得荐</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">值得荐</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">值得推荐的原创文章，技术文章或是科普文章</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.wortyby.com/2018/12/14/An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="1One's Dad"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="值得荐"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">An Introduction to Random Forest using the fastai Library (Machine Learning for Programmers — Part 1)</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T13:10:53+08:00">2018-12-14 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/假设检验/" itemprop="url" rel="index"><span itemprop="name">假设检验</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4,813 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">30 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>Programming is a crucial prerequisite for anyone wanting to learn machine learning. Sure quite a few autoML tools are out there, but most are still at a very nascent stage and well beyond an individual’s budget. The sweet spot for a data scientist lies in combining programming with machine learning algorithms.</p><p><a href="http://Fast.ai" target="_blank" rel="noopener">Fast.ai</a> led by the amazing partnership of Jeremy Howard and Rachel Thomas. So when they released their machine learning course, I couldn’t wait to get started.</p><p>What I personally liked about this course is the top-down approach to teaching. You first learn how to code an algorithm in Python, and then move to the theory aspect. While not a unique approach, it certainly has it’s advantages.</p><p>While going these videos, I decided to curate my learning in the form of a series of articles for our awesome community! So in this first post, I have provided a comprehensive summary (including the code) of the first two videos where Jeremy Howard teaches us how to build a random forest model using the fastai library, and how tuning the different hyperparameters can significantly alter our model’s accuracy.</p><p>You need to have a bit of experience in Python to follow along with the code. So if you’re a beginner in machine learning and have not used Python and Jupyter Notebooks before, I recommend checking out the below two resources first:</p><p>Introduction to Data Science (covers the basics of Python, Statistics and Predictive Modeling)<br>Beginner’s Guide to Jupyter Notebooks<br>Table of contents<br>Course Structure and Materials<br>Introduction to Machine Learning: Lesson 1<br>2.1 Importing Necessary Libraries<br>2.2 Downloading the Dataset<br>2.3 Introduction to Random Forest<br>2.4 Preprocessing<br>2.5 Model Building<br>Introduction to Machine Learning: Lesson 2<br>3.1 Creating a validation set<br>3.2 Creating a single tree<br>Additional Topics<br>Course Structure and Materials<br>The video lectures are available on YouTube and the course has been divided into twelve lectures as per the below structure:</p><p>Lesson 1 — Introduction to Random Forests<br>Lesson 2 — Random Forest Deep Dive<br>Lesson 3 — Performance, Validation and Model Interpretation<br>Lesson 4 — Feature Importance, Tree Interpreter<br>Lesson 5 — Extrapolation and RF from Scratch<br>Lesson 6 — Data Products and Live Coding<br>Lesson 7 — RF from Scratch and Gradient Descent<br>Lesson 8 — Gradient Descent and Logistic Regression<br>Lesson 9 — Regularization, Learning Rates, and NLP<br>Lesson 10 — More NLP and Columnar Data<br>Lesson 11 — Embeddings<br>Lesson 12 — Complete Rossman, Ethical Issues<br>This course assumes that you have Jupyter Notebook installed on your machine. In case you don’t (and don’t prefer installing it either), you can choose any of the following (these have a nominal fee attached to them):</p><p>Crestle<br>Paperspace<br>All the Notebooks associated with each lecture are available on <a href="http://fast.ai" target="_blank" rel="noopener">fast.ai</a>’s GitHub repository. You can clone or download the entire repository in one go. You can locate the full installation steps under the to-install section.</p><p>Introduction to Machine Learning: Lesson 1<br>Ready to get started? Then check out the Jupyter Notebook and the below video for the first lesson.</p><p>In this lecture, we will learn how to build a random forest model in Python. Since a top-down approach is followed in this course, we will go ahead and code first while simultaneously understanding how the code work. We’ll then look into the inner workings of the random forest algorithm.</p><p>Let’s deep dive into what this lecture covers.</p><p>Importing necessary libraries<br>%load ext_autoreload<br>%autoreload 2<br>The above two commands will automatically modify the notebook when the source code is updated. Thus, using ext_autoreload will automatically and dynamically make the changes in your notebook.</p><p>%matplotlib inline<br>Using %matplotlib inline, we can visualize the plots inside the notebook.</p><p>from fastai.imports import*<br>from fastai.structured import *<br>from pandas_summary import DataFrameSummary<br>from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier<br>from IPython.display import display<br>from sklearn import metrics<br>Using import* will import everything in the fastai library. Other necessary libraries have also been imported for reading the dataframe summary, creating random forest models and metrics for calculating the RMSE (evaluation metric).</p><p>Downloading the Dataset<br>The dataset we’ll be using is the ‘Blue Book for Bulldozers’. The problem statement for this challenge is described below:</p><p>The goal is to predict the sale price of a particular piece of heavy equipment at an auction, based on its usage, equipment type, and configuration. The data is sourced from auction result postings and includes information on usage and equipment configurations. Fast Iron is creating a “blue book for bulldozers”, for customers to value what their heavy equipment fleet is worth at an auction.</p><p>The evaluation metric is RMSLE (root mean squared log error). Don’t worry if you haven’t heard of it before, we’ll understand and deal with it during the code walk-through. Assuming you have successfully downloaded the dataset, let’s move on to coding!</p><p>PATH = “data/bulldozers/”<br>This command is used to set the location of our dataset. We currently have the downloaded dataset stored in a folder named bulldozers within the data folder. To check what are the files inside the PATH, you can type:</p><p>!ls data/bulldozers/<br>Or,</p><p>!ls {PATH}<br>Reading the files<br>The dataset provided is in a .csv format. This is a structured dataset, with columns representing a range of things, such as ID, Date, state, product group, etc. For dealing with structured data, pandas is the most important library. We already imported pandas as pd when we used the import* command earlier. We will now use the read_csv function of pandas to read the data :</p><p>df_raw = pd.read_csv(f’{PATH}Train.csv’, low_memory=False, parse_dates=[“saledate”])<br>Let us look at the first few rows of the data:</p><p>df_raw.head()<br>Since the dataset is large, this command does not show us the complete column-wise data. Instead, we will see some dots for the data that isn’t being displayed (as shown in the screenshot):</p><p>To fix this, we will define the following function, where we set max.rows and max.columns to 1000.</p><p>def display_all(df):<br>with pd.option_context(“display.max_rows”, 1000, display.max_columns&quot;, 1000):<br>display(df)<br>We can now print the head of the dataset using this newly minted function. We have taken the transpose to make it visually appealing (we see column names as the index).</p><p>display_all(df_raw.head().transpose())</p><p>Remember the evaluation metric is RMSLE — which is basically the RMSE between the log values of the result. So we will transform the target variable by taking it’s log values. This is where the popular library numpy comes to the rescue.</p><p>df_raw.SalePrice = np.log(df_raw.SalePrice)<br>Introduction to Random Forest<br>The concept of how a Random Forest model works from scratch will be discussed in detail in the later sections of the course, but here is a brief introduction in Jeremy Howard’s words:</p><p>Random forest is a kind of universal machine learning technique<br>It can be used for both regression (target is a continuous variable) or classification (target is a categorical variable) problems<br>It also works with columns of any kinds, like pixel values, zip codes, revenue, etc.<br>In general, random forest does not overfit (it’s very easy to stop it from overfitting)<br>You do not need a separate validation set in general. It can tell you how well it generalizes even if you only have one dataset<br>It has few (if any) statistical assumptions (it doesn’t assume that data is normally distributed, data is linear, or that you need to specify the interactions)<br>Requires very few feature engineering tactics, so it’s a great place to start. For many different types of situations, you do not have to take the log of the data or multiply interactions together<br>Sounds like a smashing technique, right?</p><p>RandomForestRegressor and RandomForestClassifier functions are used in Python for regression and classification problems respectively. Since we’re dealing with a regression challenge, we will stick to the RandomForestRegressor.</p><p>m = RandomForestRegressor(n_jobs=-1) m.fit(df_raw.drop(‘SalePrice’, axis=1), df_raw.SalePrice)<br>The m.fit function takes two inputs:</p><p>Independent variables<br>Dependent (target) variable<br>The target variable here is df_raw.SalePrice. The independent variables are all the variables except SalePrice. Here, we are using df_raw.drop to drop the SalePrice column (axis = 1 represents column). This would throw up an error like the one below:</p><p>ValueError: could not convert string to float: ‘Conventional’<br>This suggests that the model could not deal with the value ‘Conventional’. Most machine learning models (including random forest) cannot directly use categorical columns. We need to convert these columns into numbers first. So naturally the next step is to convert all the categorical columns into continuous variables.</p><p>Data Preprocessing<br>Let’s take each categorical column individually. First, consider the saledate column which is of datetime format. From the date column, we can extract numerical values such as — year, month, day of month, day of the week, holiday or not, weekend or weekday, was it raining?, etc.</p><p>We’ll leverage the add_datepart function from the fastai library to create these features for us. The function creates the following features:</p><p>‘Year’, ‘Month’, ‘Week’, ‘Day’, ‘Dayofweek’, ‘Dayofyear’, ‘Is_month_end’, ‘Is_month_start’, ‘Is_quarter_end’, ‘Is_quarter_start’, ‘Is_year_end’, ‘Is_year_start’<br>Let’s run the function and check the columns:</p><p>add_datepart(df_raw, ‘saledate’)<br>df_raw.columns<br>output:</p><p>Index([‘SalesID’, ‘SalePrice’, ‘MachineID’, ‘ModelID’, ‘datasource’, ‘auctioneerID’, ‘YearMade’, ‘MachineHoursCurrentMeter’, ‘UsageBand’, ‘fiModelDesc’, ‘fiBaseModel’, ‘fiSecondaryDesc’, ‘fiModelSeries’, ‘fiModelDescriptor’, ‘ProductSize’, ‘fiProductClassDesc’, ‘state’, ‘ProductGroup’, ‘ProductGroupDesc’, ‘Drive_System’, ‘Enclosure’, ‘Forks’, ‘Pad_Type’, ‘Ride_Control’, ‘Stick’, ‘Transmission’, ‘Turbocharged’, ‘Blade_Extension’, ‘Blade_Width’, ‘Enclosure_Type’, ‘Engine_Horsepower’, ‘Hydraulics’, ‘Pushblock’, ‘Ripper’, ‘Scarifier’, ‘Tip_Control’, ‘Tire_Size’, ‘Coupler’, ‘Coupler_System’, ‘Grouser_Tracks’, ‘Hydraulics_Flow’, ‘Track_Type’, ‘Undercarriage_Pad_Width’, ‘Stick_Length’, ‘Thumb’, ‘Pattern_Changer’, ‘Grouser_Type’, ‘Backhoe_Mounting’, ‘Blade_Type’, ‘Travel_Controls’, ‘Differential_Type’, ‘Steering_Controls’, ‘saleYear’, ‘saleMonth’, ‘saleWeek’, ‘saleDay’, ‘saleDayofweek’, ‘saleDayofyear’, ‘saleIs_month_end’, ‘saleIs_month_start’, ‘saleIs_quarter_end’, ‘saleIs_quarter_start’, ‘saleIs_year_end’, ‘saleIs_year_start’, ‘saleElapsed’], dtype=‘object’)<br>The next step is to convert the categorical variables into numbers. We can use the train_cats function from fastai for this:</p><p>train_cats(df_raw)<br>While converting categorical to numeric columns, we have to take the following two issues into consideration:</p><p>Some categorical variables can have an order among them (for example — High&gt;Medium&gt;Low). We can use set_categories to set the order.<br>If a category gets a particular number in the train data, it should have the same value in the test data. For instance, if the train data has 3 for high and test data has 2, then it will have two different meanings. We can use apply_cats for validation and test sets to make sure that the mappings are the same throughout the different sets<br>Although this won’t make much of a difference in our current case since random forest works on splitting the dataset (we will understand how random forest works in detail in the shortly), it’s still good to know this for other algorithms.</p><p>Missing Value Treatment<br>The next step is to look at the number of missing values in the dataset and understand how to deal with them. This is a pretty widespread challenge in both machine learning competitions and real-life industry problems.</p><p>display_all(df_raw.isnull().sum().sort_index()/len(df_raw))<br>We use .isnull().sum() to get the total number of missing values. This is divided by the length of the dataset to determine the ratio of missing values.</p><p>The dataset is now ready to be used for creating a model. Data cleaning is always a tedious and time consuming process. Hence, ensure to save the transformed dataset so that the next time we load the data, we will not have to perform the above tasks again.</p><p>We will save it in a feather format, as this let’s us access the data efficiently:</p><p>#to save<br>os.makedirs(‘tmp’, exist_ok=True)<br>df.to_feather(‘tmp/bulldozers-raw’)</p><p>#to read<br>df_raw = pd.read_feather(‘tmp/bulldozers-raw’)<br>We have to impute the missing values and store the data as dependent and independent part. This is done by using the fastai function proc_df. The function performs the following tasks:</p><p>For continuous variables, it checks whether a column has missing values or not<br>If the column has missing values, it creates another column called columnname_na, which has 1 for missing and 0 for not missing<br>Simultaneously, the missing values are replaced with the median of the column<br>For categorical variables, pandas replaces missing values with -1. So proc_df adds 1 to all the values for categorical variables. Thus, we have 0 for missing while all other values are incremented by 1<br>df, y, nas = proc_df(df_raw, ‘SalePrice’)<br>Model Building<br>We have dealt with the categorical columns and the date values. We have also taken care of the missing values. Now we can finally power up and build the random forest model we have been inching towards.</p><p>m = RandomForestRegressor(n_jobs=-1)<br>m.fit(df, y)<br>m.score(df,y)<br>The n_jobs is set to -1 to use all the available cores on the machine. This gives us a score (r²) of 0.98, which is excellent. The caveat here is that we have trained the model on the training set, and checked the result on the same. There’s a high chance that this model might not perform as well on unseen data (test set, in our case).</p><p>The only way to find out is to create a validation set and check the performance of the model on it. So let’s create a validation set that contains 12,000 data points (and the train set will contain the rest).</p><p>def split_vals(a,n):<br>return a[:n].copy(), a[n:].copy()</p><p>n_valid = 12000 # same as Kaggle’s test set size<br>n_trn = len(df)-n_valid<br>raw_train, raw_valid = split_vals(df_raw, n_trn)<br>X_train, X_valid = split_vals(df, n_trn)<br>y_train, y_valid = split_vals(y, n_trn)</p><p>X_train.shape, y_train.shape, X_valid.shape<br>Output:</p><p>((389125, 66), (389125,), (12000, 66))<br>Here, we will train the model on our new set (which is a sample of the original set) and check the performance across both — train and validation sets.</p><p>#define a function to check rmse value<br>def rmse(x,y):<br>return math.sqrt(((x-y)**2).mean())<br>In order to compare the score against the train and test sets, the below function returns the RMSE value and score for both datasets.</p><p>def print_score(m):<br>res = [rmse(m.predict(X_train), y_train),<br>rmse(m.predict(X_valid), y_valid),<br>m.score(X_train, y_train), m.score(X_valid, y_valid)]<br>if hasattr(m, ‘oob_score_’): res.append(m.oob_score_)<br>print(res)<br>m = RandomForestRegressor(n_jobs=-1)<br>%time m.fit(X_train, y_train)<br>print_score(m)<br>The result of the above code is shown below. The train set has a score of 0.98, while the validation set has a score of 0.88. A bit of a drop-off, but the model still performed well overall.</p><p>CPU times: user 1min 3s, sys: 356 ms, total: 1min 3s<br>Wall time: 8.46 s<br>[0.09044244804386327, 0.2508166961122146, 0.98290459302099709, 0.88765316048270615]<br>Introduction to Machine Learning: Lesson 2<br>Now that you know how to code a random forest model in Python, it’s equally important to understand how it actually works underneath all that code. Random forest is often cited as a black box model, and it’s time to put that misconception to bed.</p><p>We observed in the first lesson that the model performs extremely well on the training data (the points it has seen before) but dips when tested on the validation set (the data points model was not trained on). Let us first understand how we created the validation set and why it’s so crucial.</p><p>Creating a Validation set<br>Creating a good validation set that closely resembles the test set is one of the most important tasks in machine learning. The validation score is representative of how our model performs on real-world data, or on the test data.</p><p>Keep in mind that if there’s a time component involved, then the most recent rows should be included in the validation set. So, our validation set will be of the same size as the test set (last 12,000 rows from the training data).</p><p>def split_vals(a,n):<br>return a[:n].copy(), a[n:].copy()</p><p>n_valid = 12000<br>n_trn = len(df)-n_valid<br>raw_train, raw_valid = split_vals(df_raw, n_trn)<br>X_train, X_valid = split_vals(df, n_trn)<br>y_train, y_valid = split_vals(y, n_trn)<br>The data points from 0 to (length — 12000) are stored as the train set (x_train, y_train). A model is built using the train set and its performance is measured on both the train and validation sets as before.</p><p>m = RandomForestRegressor(n_jobs=-1)<br>%time m.fit(X_train, y_train)<br>print_score(m)<br>Result :</p><p>CPU times: user 1min 3s, sys: 356 ms, total: 1min 3s<br>Wall time: 8.46 s<br>[0.09044244804386327, 0.2508166961122146, 0.98290459302099709, 0.88765316048270615]<br>From the above code, we get the results:</p><p>RMSE on the training set<br>RMSE on the validation set<br>R-square on the training set<br>R-square on validation set<br>It’s clear that the model is overfitting on the training set. Also, it takes a smidge over 1 minute to train. Can we reduce the training time? Yes, we can! To do this, we will further take a subset of the original dataset:</p><p>df_trn, y_trn, nas = proc_df(df, ‘SalePrice’, subset=30000)<br>X_train, _ = split_vals(df_trn, 20000)<br>y_train, _ = split_vals(y_trn, 20000)<br>A subset of 30,000 samples has been created from which we take 20,000 for training the Random Forest model.</p><p>Building a single tree<br>Random Forest is a group of trees which are called estimators. The number of trees in a random forest model is defined by the parameter n_estimator. We will first look at a single tree (set n_estimator = 1) with a maximum depth of 3.</p><p>m = RandomForestRegressor(n_estimators=1, max_depth=3, bootstrap=False, n_jobs=-1)<br>m.fit(X_train, y_train)<br>print_score(m)<br>Result:</p><p>[0.4965829795739235, 0.5246832258551836, 0.50149617735615859, 0.5083655198087873]<br>Plotting the tree:</p><p>draw_tree(m.estimators_[0], df_trn, precision=3)</p><p>The tree is a set of binary decisions. Looking at the first box, the first split is on coupler-system value: less than/equal to 0.5 or greater than 0.5. After the split, we get 3,185 rows with coupler_system&gt;0.5 and remaining 16,815 with &lt;0.5. Similarly, next split is on enclosure and Year_made.</p><p>For the first box, a model is created using only the average value (10.189). This means that all the rows have a predicted value of 10.189 and the MSE (Mean Squared Error) for these predictions is 0.459. Instead, if we make a split and separate the rows based on coupler_system &lt;0.5, the MSE is reduced to 0.414 for samples satisfying the condition (true) and 0.109 for the remaining samples.</p><p>So how do we decide which variable to split on? The idea is to split the data into two groups which are as different from each other as possible. This can be done by checking each possible split point for each variable, and then figuring out which one gives the lower MSE. To do this, we can take a weighted average of the two MSE values after the split. The splitting stops when it either reaches the pre-specified max_depth value or when each leaf node has only one value.</p><p>We have a basic model — a single tree, but this is not a very good model. We need something a bit more complex that builds upon this structure. For creating a forest, we will use a statistical technique called bagging.</p><p>Introduction to Bagging<br>In the bagging technique, we create multiple models, each giving predictions which are not correlated to the other. Then we average the predictions from these models. Random Forest is a bagging technique.</p><p>If all the trees created are similar to each other and give similar predictions, then averaging these predictions will not improve the model performance. Instead, we can create multiple trees on a different subset of data, so that even if these trees overfit, they will do so on a different set of points. These samples are taken with replacement.</p><p>In simple words, we create multiple poor performing models and average them to create one good model. The individual models must be as predictive as possible, but together should be uncorrelated. We will now increase the number of estimators in our random forest and see the results.</p><p>m = RandomForestRegressor(n_jobs=-1)<br>m.fit(X_train, y_train)<br>print_score(m)<br>If we do not give a value to the n_estimator parameter, it is taken as 10 by default. We will get predictions from each of the 10 trees. Further, np.stack will be used to concatenate the predictions one over the other.</p><p>preds = np.stack([t.predict(X_valid) for t in m.estimators_])<br>preds.shape<br>The dimensions of the predictions is (10, 12000) . This means we have 10 predictions for each row in the validation set.</p><p>Now for comparing our model’s results against the validation set, here is the row of predictions, the mean of the predictions and the actual value from validation set.</p><p>preds[:,0], np.mean(preds[:,0]), y_valid[0]<br>The actual value is 9.17 but none of our predictions comes close to this value. On taking the average of all our predictions we get 9.07, which is a better prediction than any of the individual trees.</p><p>(array([ 9.21034, 8.9872 , 8.9872 , 8.9872 , 8.9872 , 9.21034, 8.92266, 9.21034, 9.21034, 8.9872 ]),<br>9.0700003890739005,<br>9.1049798563183568)<br>It’s always a good idea to visualize your model as much as possible. Here is a plot that shows the variation in r² value as the number of trees increases.</p><p>plt.plot([metrics.r2_score(y_valid, np.mean(preds[:i+1], axis=0)) for i in range(10)]);</p><p>As expected, the r² becomes better as the number of trees increases. You can experiment with the n_estimator value and see how the r² value changes with each iteration. You’ll notice that after a certain number of trees, the r² value plateaus.</p><p>Out-of-Bag (OOB) Score<br>Creating a separate validation set for a small dataset can potentially be a problem since it will result in an even smaller training set. In such cases, we can use the data points (or samples) which the tree was not trained on.</p><p>For this, we set the parameter oob_score =True.</p><p>m = RandomForestRegressor(n_estimators=40, n_jobs=-1, oob_score=True)<br>m.fit(X_train, y_train)<br>print_score(m)</p><p>[0.10198464613020647, 0.2714485881623037, 0.9786192457999483, 0.86840992079038759, 0.84831537630038534]<br>The oob_score is 0.84 which is close to that of the validation set. Let us look at some other interesting techniques by which we can improve our model.</p><p>Subsampling<br>Earlier, we created a subset of 30,000 rows and the train set was randomly chosen from this subset. As an alternative, we can create a different subset each time so that the model is trained on a larger part of the data.</p><p>df_trn, y_trn, nas = proc_df(df_raw, ‘SalePrice’)<br>X_train, X_valid = split_vals(df_trn, n_trn)<br>y_train, y_valid = split_vals(y_trn, n_trn)<br>set_rf_samples(20000)<br>We use set_rf_sample to specify the sample size. Let us check if the performance of the model has improved or not.</p><p>m = RandomForestRegressor(n_estimators=40, n_jobs=-1, oob_score=True)<br>m.fit(X_train, y_train)<br>print_score(m)</p><p>[0.2317315086850927, 0.26334275954117264, 0.89225792718146846, 0.87615150359885019, 0.88097587673696554]<br>We get a validation score of 0.876. So far, we have worked on a subset of one sample. We can fit this model on the entire dataset (but it will take a long time to run depending on how good your computational resources are!).</p><p>reset_rf_samples()<br>m = RandomForestRegressor(n_estimators=40, n_jobs=-1, oob_score=True)<br>m.fit(X_train, y_train)<br>print_score(m)</p><p>[0.07843013746508616, 0.23879806957665775, 0.98490742269867626, 0.89816206196980131, 0.90838819297302553]<br>Other Hyperparameters to Experiment with and Tune<br>Min sample leaf<br>This can be treated as the stopping criteria for the tree. The tree stops growing (or splitting) when the number of samples in the leaf node is less than specified.</p><p>m = RandomForestRegressor(n_estimators=40, min_samples_leaf=3,n_jobs=-1, oob_score=True)<br>m.fit(X_train, y_train)<br>print_score(m)</p><p>[0.11595869956476182, 0.23427349924625201, 0.97209195463880227, 0.90198460308551043, 0.90843297242839738]<br>Here we have specified the min_sample_leaf as 3. This means that the minimum number of samples in the node should be 3 for each split. We see that the r² has improved for the validation set and reduced on the test set, concluding that the model does not overfit on the training data.</p><p>Max feature<br>Another important parameter in random forest is max_features. We have discussed previously that the individual trees must be as uncorrelated as possible. For the same, random forest uses a subset of rows to train each tree. Additionally, we can also use a subset of columns (features) instead of using all the features. This is achieved by tweaking the max_features parameter.</p><p>m = RandomForestRegressor(n_estimators=40, min_samples_leaf=3, max_features=0.5, n_jobs=-1, oob_score=True)<br>m.fit(X_train, y_train)<br>print_score(m)</p><p>[0.11926975747908228, 0.22869111042050522, 0.97026995966445684, 0.9066000722129437, 0.91144914977164715]<br>Setting max_features has slightly improved the validation score. Here the max_features is set to 0.5 which means using 50% of the features for each split. Keep in mind that this parameter can also take values like log2 or sqrt.</p><p>Additional Topics<br>Tips and tricks in Jupyter Notebooks<br>Jeremy Howard mentioned a few tips and tricks for navigating Jupyter Notebooks which newcomers will find quite useful. Below are some of the highlights:</p><p>To find out which library the function is located in, simply type the function name and run the cell (shift-enter):<br>display</p><p>To see the documentation, use a question mark before the function:<br>?display</p><p>To see the source code of the function, use a double question mark before the function name:<br>??display</p><p>Curse of dimensionality<br>The curse of dimensionality is the idea that the more dimensions we have, the more points sit on the edge of that space. So if the number of columns is more, it creates more and more empty space. What that means, in theory, is that the distance between points is much less meaningful. This should not be true because the points still are different distances away from each other. Even though they are on the edges, we can still determine how far away they are from each other.</p><p>Continuous, categorical, ordinal variables<br>Continuous variables are variables with integer or float values. For example — Age, distance, weight, income etc<br>Categorical variables are usually strings or values representing names or labels. For example — gender, state, zip code, rank etc<br>Ordinal variables are those categorical variables which have an order among them. For example rank (I, II, III ) or remark (poor, good, excellent) have an order.<br>Overfitting and Underfitting</p><p>Underfitting: A model that performs poorly on the train data and also on the test data. The model does not generalize well. (left plot)<br>Overfitting: A model that performs extremely well on the train data but does not show a similar high performance on the test data. (right plot)<br>Root mean squared log error<br>The evaluation metric of our dataset is RMSLE. The formula for this is</p><p>We first take the mean of squared differences of log values. We take a square root of the result obtained. This is equivalent to calculating the root mean squared error (rmse) of log of the values.</p><p>R-square<br>Here is the mathematical formula for R-square:</p><p>SSregression is the sum of squares of (actual value — prediction)<br>SStotal is the sum of squares of (actual value — average)<br>The value of R-square can be anything less than 1. If the r square is negative, it means that your model is worse than predicting mean.</p><p>Extremely Randomized Tree<br>In scikit-learn, we have another algorithm ExtraTreeClassifier which is extremely randomized tree model. Unlike Random forest, instead of trying each split point for every variable, it randomly tries a few split points for a few variables.</p><p>End Notes<br>This article was a pretty comprehensive summary of the first two videos from <a href="http://fast.ai" target="_blank" rel="noopener">fast.ai</a>’s machine learning course. During the first lesson we learnt to code a simple random forest model on the bulldozer dataset. Random forest (and most ml algorithms) do not work with categorical variables. We faced a similar problem during the random forest implementation and we saw hoe can we use the date column and other categorical columns in the dataset for creating a model.</p><p>In the second video, the concept of creating a validation set was introduced. We then used this validation set to check the performance of the model and tuned some basic hyper-parameters to improve the model. My favorite part from this video was plotting and visualizing the tree we built. I am sure you would have learnt a lot through these videos. I will shortly post another article covering the next two videos from the course.</p><p>Update: Here is part two of the series (Covers Lesson 3, 4 and 5)</p><p>An Intuitive Guide to Interpret a Random Forest Model using fastai library (Machine learning for Programmers — Part 2)</p><p>Originally published at <a href="http://www.analyticsvidhya.com" target="_blank" rel="noopener">www.analyticsvidhya.com</a> on October 8, 2018.</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>~赏你叻~</div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="1One's Dad 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/自由度/" rel="tag"># 自由度</a> <a href="/tags/原假设/" rel="tag"># 原假设</a> <a href="/tags/对立假设/" rel="tag"># 对立假设</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/11/27/Python 日常/" rel="next" title="Python日常"><i class="fa fa-chevron-left"></i> Python日常</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/12/18/Spark 提交PYTHON 那点事/" rel="prev" title="Spark 提交 Python 那点事">Spark 提交 Python 那点事 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">1One's Dad</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">66</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/sevenfeng012" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=a1hfWFpbU15TXSsaGkUIBAY" target="_blank" title="E-Mail"><i class="fa fa-fw fa-邮件"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/feng-seven-48/activities" target="_blank" title="ZHIHU"><i class="fa fa-fw fa-知乎"></i>ZHIHU</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2011 &mdash; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">1One's Dad</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总文字&#58;</span> <span title="站点总文字">76.9k</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html><!-- rebuild by neat -->